package sync

import (
	"context"
	"io"
	"log/slog"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/eduardolat/authkeysync/internal/config"
	"github.com/eduardolat/authkeysync/internal/userinfo"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// mockUserLookup is a mock implementation of userinfo.LookupProvider
type mockUserLookup struct {
	users map[string]*userinfo.UserInfo
	err   error
}

func (m *mockUserLookup) Lookup(username string) (*userinfo.UserInfo, error) {
	if m.err != nil {
		return nil, m.err
	}
	if info, ok := m.users[username]; ok {
		return info, nil
	}
	return nil, userinfo.ErrUserNotFound
}

func TestSyncUser_Success(t *testing.T) {
	// Create temp SSH directory
	tempDir := t.TempDir()
	sshDir := filepath.Join(tempDir, ".ssh")
	require.NoError(t, os.Mkdir(sshDir, 0700))

	// Create test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ssh-ed25519 AAAA key1@host\nssh-rsa BBBB key2@host"))
	}))
	defer server.Close()

	cfg := &config.Config{
		Policy: config.Policy{},
		Users: []config.User{
			{
				Username: "testuser",
				Sources: []config.Source{
					{URL: server.URL},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, false)

	// Use mock user lookup
	syncer.userLookup = &mockUserLookup{
		users: map[string]*userinfo.UserInfo{
			"testuser": {
				Username:     "testuser",
				UID:          os.Getuid(),
				GID:          os.Getgid(),
				HomeDir:      tempDir,
				SSHDir:       sshDir,
				AuthKeysPath: filepath.Join(sshDir, "authorized_keys"),
				BackupDir:    filepath.Join(sshDir, "authorized_keys_backups"),
			},
		},
	}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.False(t, result.HasErrors)
	assert.NoError(t, result.Users[0].Error)
	assert.False(t, result.Users[0].Skipped)
	assert.Equal(t, 2, result.Users[0].KeysWritten)
	assert.True(t, result.Users[0].Changed)

	// Verify file was written
	content, err := os.ReadFile(filepath.Join(sshDir, "authorized_keys"))
	require.NoError(t, err)
	assert.Contains(t, string(content), "ssh-ed25519 AAAA key1@host")
	assert.Contains(t, string(content), "ssh-rsa BBBB key2@host")
	assert.Contains(t, string(content), "Generated by AuthKeySync")
}

func TestSyncUser_UserNotFound(t *testing.T) {
	cfg := &config.Config{
		Policy: config.Policy{},
		Users: []config.User{
			{
				Username: "nonexistent",
				Sources: []config.Source{
					{URL: "http://example.com/keys"},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, false)
	syncer.userLookup = &mockUserLookup{users: map[string]*userinfo.UserInfo{}}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.False(t, result.HasErrors) // Skipped users don't count as errors
	assert.True(t, result.Users[0].Skipped)
	assert.Equal(t, "user not found in system", result.Users[0].SkipReason)
}

func TestSyncUser_SourceFetchFails(t *testing.T) {
	tempDir := t.TempDir()
	sshDir := filepath.Join(tempDir, ".ssh")
	require.NoError(t, os.Mkdir(sshDir, 0700))

	// Create test server that returns 500
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
	}))
	defer server.Close()

	cfg := &config.Config{
		Policy: config.Policy{},
		Users: []config.User{
			{
				Username: "testuser",
				Sources: []config.Source{
					{URL: server.URL},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, false)
	syncer.userLookup = &mockUserLookup{
		users: map[string]*userinfo.UserInfo{
			"testuser": {
				Username: "testuser",
				UID:      os.Getuid(),
				GID:      os.Getgid(),
				HomeDir:  tempDir,
				SSHDir:   sshDir,
			},
		},
	}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.True(t, result.HasErrors)
	assert.Error(t, result.Users[0].Error)
	assert.Contains(t, result.Users[0].Error.Error(), "failed to fetch keys")
}

func TestSyncUser_DryRun(t *testing.T) {
	tempDir := t.TempDir()
	sshDir := filepath.Join(tempDir, ".ssh")
	require.NoError(t, os.Mkdir(sshDir, 0700))

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ssh-ed25519 AAAA key@host"))
	}))
	defer server.Close()

	cfg := &config.Config{
		Policy: config.Policy{},
		Users: []config.User{
			{
				Username: "testuser",
				Sources: []config.Source{
					{URL: server.URL},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, true) // dry-run = true
	syncer.userLookup = &mockUserLookup{
		users: map[string]*userinfo.UserInfo{
			"testuser": {
				Username: "testuser",
				UID:      os.Getuid(),
				GID:      os.Getgid(),
				HomeDir:  tempDir,
				SSHDir:   sshDir,
			},
		},
	}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.False(t, result.HasErrors)
	assert.NoError(t, result.Users[0].Error)

	// Verify no file was written
	_, err := os.Stat(filepath.Join(sshDir, "authorized_keys"))
	assert.True(t, os.IsNotExist(err))
}

func TestSyncUser_PreserveLocalKeys(t *testing.T) {
	tempDir := t.TempDir()
	sshDir := filepath.Join(tempDir, ".ssh")
	require.NoError(t, os.Mkdir(sshDir, 0700))

	// Create existing authorized_keys with local keys
	existingContent := `ssh-ed25519 AAAA local@host
ssh-rsa BBBB local2@host`
	require.NoError(t, os.WriteFile(
		filepath.Join(sshDir, "authorized_keys"),
		[]byte(existingContent),
		0600))

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ssh-ed25519 CCCC remote@host"))
	}))
	defer server.Close()

	preserveLocalKeys := true
	cfg := &config.Config{
		Policy: config.Policy{
			PreserveLocalKeys: &preserveLocalKeys,
		},
		Users: []config.User{
			{
				Username: "testuser",
				Sources: []config.Source{
					{URL: server.URL},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, false)
	syncer.userLookup = &mockUserLookup{
		users: map[string]*userinfo.UserInfo{
			"testuser": {
				Username:     "testuser",
				UID:          os.Getuid(),
				GID:          os.Getgid(),
				HomeDir:      tempDir,
				SSHDir:       sshDir,
				AuthKeysPath: filepath.Join(sshDir, "authorized_keys"),
				BackupDir:    filepath.Join(sshDir, "authorized_keys_backups"),
			},
		},
	}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.False(t, result.HasErrors)
	assert.Equal(t, 3, result.Users[0].KeysWritten)
	assert.Equal(t, 2, result.Users[0].LocalKeys)

	// Verify all keys are present
	content, err := os.ReadFile(filepath.Join(sshDir, "authorized_keys"))
	require.NoError(t, err)
	assert.Contains(t, string(content), "ssh-ed25519 CCCC remote@host")
	assert.Contains(t, string(content), "ssh-ed25519 AAAA local@host")
	assert.Contains(t, string(content), "ssh-rsa BBBB local2@host")
	assert.Contains(t, string(content), "# Local (preserved)")
}

func TestSyncUser_DoNotPreserveLocalKeys(t *testing.T) {
	tempDir := t.TempDir()
	sshDir := filepath.Join(tempDir, ".ssh")
	require.NoError(t, os.Mkdir(sshDir, 0700))

	// Create existing authorized_keys with local keys
	existingContent := `ssh-ed25519 AAAA local@host`
	require.NoError(t, os.WriteFile(
		filepath.Join(sshDir, "authorized_keys"),
		[]byte(existingContent),
		0600))

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ssh-ed25519 CCCC remote@host"))
	}))
	defer server.Close()

	preserveLocalKeys := false
	cfg := &config.Config{
		Policy: config.Policy{
			PreserveLocalKeys: &preserveLocalKeys,
		},
		Users: []config.User{
			{
				Username: "testuser",
				Sources: []config.Source{
					{URL: server.URL},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, false)
	syncer.userLookup = &mockUserLookup{
		users: map[string]*userinfo.UserInfo{
			"testuser": {
				Username:     "testuser",
				UID:          os.Getuid(),
				GID:          os.Getgid(),
				HomeDir:      tempDir,
				SSHDir:       sshDir,
				AuthKeysPath: filepath.Join(sshDir, "authorized_keys"),
				BackupDir:    filepath.Join(sshDir, "authorized_keys_backups"),
			},
		},
	}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.Equal(t, 1, result.Users[0].KeysWritten)
	assert.Equal(t, 0, result.Users[0].LocalKeys)

	// Verify only remote key is present
	content, err := os.ReadFile(filepath.Join(sshDir, "authorized_keys"))
	require.NoError(t, err)
	assert.Contains(t, string(content), "ssh-ed25519 CCCC remote@host")
	assert.NotContains(t, string(content), "local@host")
}

func TestSyncUser_Deduplication(t *testing.T) {
	tempDir := t.TempDir()
	sshDir := filepath.Join(tempDir, ".ssh")
	require.NoError(t, os.Mkdir(sshDir, 0700))

	// Two servers with overlapping keys
	server1 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ssh-ed25519 AAAA key@host\nssh-rsa BBBB key2@host"))
	}))
	defer server1.Close()

	server2 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ssh-ed25519 AAAA key@host\nssh-ed25519 CCCC key3@host")) // AAAA is duplicate
	}))
	defer server2.Close()

	cfg := &config.Config{
		Policy: config.Policy{},
		Users: []config.User{
			{
				Username: "testuser",
				Sources: []config.Source{
					{URL: server1.URL},
					{URL: server2.URL},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, false)
	syncer.userLookup = &mockUserLookup{
		users: map[string]*userinfo.UserInfo{
			"testuser": {
				Username:     "testuser",
				UID:          os.Getuid(),
				GID:          os.Getgid(),
				HomeDir:      tempDir,
				SSHDir:       sshDir,
				AuthKeysPath: filepath.Join(sshDir, "authorized_keys"),
				BackupDir:    filepath.Join(sshDir, "authorized_keys_backups"),
			},
		},
	}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.False(t, result.HasErrors)
	assert.Equal(t, 3, result.Users[0].KeysWritten) // 3 unique keys, not 4

	// Verify content
	content, err := os.ReadFile(filepath.Join(sshDir, "authorized_keys"))
	require.NoError(t, err)

	// Count occurrences of AAAA - should be exactly 1
	count := strings.Count(string(content), "ssh-ed25519 AAAA key@host")
	assert.Equal(t, 1, count)
}

func TestSyncUser_BackupCreation(t *testing.T) {
	tempDir := t.TempDir()
	sshDir := filepath.Join(tempDir, ".ssh")
	require.NoError(t, os.Mkdir(sshDir, 0700))

	// Create existing authorized_keys
	existingContent := `ssh-ed25519 AAAA old@host`
	require.NoError(t, os.WriteFile(
		filepath.Join(sshDir, "authorized_keys"),
		[]byte(existingContent),
		0600))

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ssh-ed25519 BBBB new@host"))
	}))
	defer server.Close()

	backupEnabled := true
	preserveLocalKeys := false
	cfg := &config.Config{
		Policy: config.Policy{
			BackupEnabled:     &backupEnabled,
			PreserveLocalKeys: &preserveLocalKeys,
		},
		Users: []config.User{
			{
				Username: "testuser",
				Sources: []config.Source{
					{URL: server.URL},
				},
			},
		},
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	syncer := New(cfg, logger, false)
	syncer.userLookup = &mockUserLookup{
		users: map[string]*userinfo.UserInfo{
			"testuser": {
				Username:     "testuser",
				UID:          os.Getuid(),
				GID:          os.Getgid(),
				HomeDir:      tempDir,
				SSHDir:       sshDir,
				AuthKeysPath: filepath.Join(sshDir, "authorized_keys"),
				BackupDir:    filepath.Join(sshDir, "authorized_keys_backups"),
			},
		},
	}

	result := syncer.Run(context.Background())

	require.Len(t, result.Users, 1)
	assert.False(t, result.HasErrors)
	assert.NotEmpty(t, result.Users[0].BackupPath)

	// Verify backup exists
	_, err := os.Stat(result.Users[0].BackupPath)
	require.NoError(t, err)

	// Verify backup content
	backupContent, err := os.ReadFile(result.Users[0].BackupPath)
	require.NoError(t, err)
	assert.Equal(t, existingContent, string(backupContent))
}

func TestTruncateKey(t *testing.T) {
	tests := []struct {
		name     string
		key      string
		maxLen   int
		expected string
	}{
		{
			name:     "short key",
			key:      "ssh-ed25519 AAAA",
			maxLen:   60,
			expected: "ssh-ed25519 AAAA",
		},
		{
			name:     "exactly max length",
			key:      "1234567890",
			maxLen:   10,
			expected: "1234567890",
		},
		{
			name:     "truncated",
			key:      "ssh-ed25519 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA user@host",
			maxLen:   30,
			expected: "ssh-ed25519 AAAAAAAAAAAAAAA...",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := truncateKey(tt.key, tt.maxLen)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestNew(t *testing.T) {
	cfg := &config.Config{}
	logger := slog.New(slog.NewTextHandler(io.Discard, nil))

	syncer := New(cfg, logger, false)

	assert.NotNil(t, syncer)
	assert.NotNil(t, syncer.fetcher)
	assert.NotNil(t, syncer.backupManager)
	assert.NotNil(t, syncer.fileWriter)
	assert.NotNil(t, syncer.userLookup)
	assert.False(t, syncer.dryRun)
}

func TestKeyFingerprint(t *testing.T) {
	tests := []struct {
		name     string
		key      string
		expected string // If not empty, expects exact match; otherwise expects SHA256:...
	}{
		{
			name: "valid ed25519 key",
			key:  "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGit user@host",
		},
		{
			name: "valid rsa key",
			key:  "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQ user@host",
		},
		{
			name: "key with options",
			key:  "restrict,port-forwarding ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGit user@host",
		},
		{
			name: "single field",
			key:  "invalid",
		},
		{
			name:     "empty key",
			key:      "",
			expected: "(empty)",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := keyFingerprint(tt.key)
			if tt.expected != "" {
				assert.Equal(t, tt.expected, result)
			} else {
				assert.True(t, strings.HasPrefix(result, "SHA256:"),
					"expected SHA256: prefix, got: %s", result)
				// SHA256: followed by 16 hex characters (8 bytes)
				assert.Len(t, result, 23) // "SHA256:" (7) + 16 hex chars
			}
		})
	}
}
