package e2e

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

// TestPartialFailure verifies that when one user fails, other users can still succeed.
func TestPartialFailure(t *testing.T) {
	_ = newTestCase(t, testUser1, testUser2)

	originalKey1 := "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPFAIL111111111111111111111111111111111111111111 pfail@user1"
	originalKey2 := "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPFAIL222222222222222222222222222222222222222222 pfail@user2"

	// Create existing authorized_keys for both users
	createExistingKeys(t, testUser1, originalKey1)
	createExistingKeys(t, testUser2, originalKey2)

	// Create config: user1 has failing source, user2 has valid source
	configPath := createConfig(t, "partial_failure", `
policy:
  backup_enabled: false
  preserve_local_keys: false

users:
  - username: `+testUser1+`
    sources:
      - url: ${MOCK_SERVER_URL}/error/500

  - username: `+testUser2+`
    sources:
      - url: ${MOCK_SERVER_URL}/users/bob.keys
`)

	// Execute
	output, exitCode := runAuthKeySync(t, "--config", configPath)
	t.Logf("Output: %s", output)

	// Should exit with code 1 (at least one user failed)
	assert.Equal(t, 1, exitCode, "authkeysync should exit with code 1 (partial failure)")

	// User 1 should be unchanged (failed)
	content1 := readAuthKeys(t, testUser1)
	assert.Contains(t, content1, "pfail@user1", "User1 should keep original key (sync failed)")
	assert.NotContains(t, content1, "Generated by AuthKeySync", "User1 should not have AuthKeySync header")

	// User 2 should be updated (succeeded)
	content2 := readAuthKeys(t, testUser2)
	assert.Contains(t, content2, "bob@desktop", "User2 should have new key")
	assert.Contains(t, content2, "Generated by AuthKeySync", "User2 should have AuthKeySync header")
	assert.NotContains(t, content2, "pfail@user2", "User2 should not have original key")
}
